#!/usr/bin/env python3
"""
The main function will gather device serial numbers over different input options (argument list, Excel or
dynamically with Nornir) as well as the hostname. With the serial numbers the Cisco support APIs will be
called and the received information will be printed to stdout and optional processed into an Excel report.
Optionally a IBM TSS Maintenance Report can be added with an argument to compare and analyze the IBM TSS
information against the received data from the Cisco support APIs. Also these additional data will be
processed into an Excel report and saved to the local disk.
"""

import os
import argparse
from datetime import datetime, timedelta
from nornir import InitNornir
from nornir.core import Nornir
from nornir_maze.cisco_support.utils import init_args, prepare_nornir_data, prepare_static_serials
from nornir_maze.cisco_support.reports import (
    create_pandas_dataframe_for_report,
    # generate_cisco_maintenance_report,
)
from nornir_maze.cisco_support.api_calls import (
    cisco_support_check_authentication,
    get_sni_owner_coverage_by_serial_number,
    get_sni_coverage_summary_by_serial_numbers,
    get_eox_by_serial_numbers,
    get_ss_suggested_release_by_pid,
    print_sni_owner_coverage_by_serial_number,
    print_sni_coverage_summary_by_serial_numbers,
    print_eox_by_serial_numbers,
    print_get_ss_suggested_release_by_pid,
)
from nornir_maze.utils import (
    print_script_banner,
    print_task_title,
    nr_filter_args,
    nr_transform_default_creds_from_env,
    nr_transform_inv_from_env,
    exit_info,
    exit_error,
    task_info,
    print_task_name,
    get_pandas_column_width,
    construct_filename_with_current_date,
    load_yaml_file,
)
import pandas as pd
from xlsxwriter.utility import xl_col_to_name


__author__ = "Willi Kubny"
__maintainer__ = "Willi Kubny"
__license__ = "MIT"
__email__ = "willi.kubny@kyndryl.com"
__status__ = "Production"


def _worksheet_add_title_row(workbook, worksheet, config):
    """
    TBD
    """
    # Setting for the whole worksheet
    zoom = config["zoom"] if "zoom" in config else 110
    worksheet.set_zoom(zoom)
    # Specify how many columns should be frozen
    freeze_col = config["freeze_columns"] if "freeze_columns" in config else 0
    freeze_row = config["freeze_row"] if "freeze_row" in config else 2
    worksheet.freeze_panes(freeze_row, freeze_col)

    # Set the top row height
    worksheet.set_row(0, config["title_row_height"] if "title_row_height" in config else 60)
    # Create a format to use for the merged top row
    title_format = workbook.add_format(
        {
            "font_name": config["title_font_name"] if "title_font_name" in config else "Calibri",
            "font_size": config["title_font_size"] if "title_font_size" in config else 20,
            "font_color": config["title_font_color"] if "title_font_color" in config else "#FFFFFF",
            "bg_color": config["title_bg_color"] if "title_bg_color" in config else "#FF452C",
            "align": "left",
            "valign": "vcenter",
            "bold": 1,
            "bottom": 1,
        }
    )
    # Insert a logo to the top row
    if "title_logo" in config:
        # Merge the number of top row cells according to the frozen columns to insert a logo
        worksheet.merge_range(0, 0, 0, freeze_col - 1 if freeze_col != 0 else freeze_col, None, title_format)
        worksheet.insert_image(
            "A1",
            config["title_logo"],
            {
                "x_scale": config["title_logo_x_scale"],
                "y_scale": config["title_logo_y_scale"],
                "x_offset": config["title_logo_x_offset"],
                "y_offset": config["title_logo_y_offset"],
            },
        )
    # Specify the title text
    if "tss_report" in config:
        title_text = (
            config["title_text_tss"]
            if "title_text_tss" in config
            else "Cisco Maintenance Report incl. IBM TSS Analysis"
        )
    else:
        title_text = config["title_text"] if "title_text" in config else "Cisco Maintenance Report"
    # Merge from the cell 3 to the max_col and write a title
    title_text = f"{title_text} (generated by {os.path.basename(__file__)})"
    worksheet.merge_range(0, freeze_col, 0, config["max_col"], title_text, title_format)

    return worksheet


def _worksheet_add_table(df, workbook, worksheet, config):
    """
    TBD
    """
    # pylint: disable=invalid-name

    # Create a list of column headers, to use in add_table().
    columns = [{"header": column} for column in df.columns]

    # Add the Excel table structure. Pandas will add the data.
    # fmt: off
    worksheet.add_table(1, 0, config["max_row"] - 1, config["max_col"],
        {
            "columns": columns,
            "style": config["table_style"] if "table_style" in config else "Table Style Medium 8",
        },
    )
    # fmt: on

    table_format = workbook.add_format(
        {
            "font_name": config["table_font_name"] if "table_font_name" in config else "Calibri",
            "font_size": config["table_font_size"] if "table_font_size" in config else 11,
            "align": "left",
            "valign": "vcenter",
        }
    )
    # Auto-adjust each column width -> +1 on the width makes space for the filter icon
    for index, width in enumerate(get_pandas_column_width(df)):
        worksheet.set_column(index, index - 1, width + 1, table_format)

    return worksheet


def _worksheet_add_conditional_formatting(df, workbook, worksheet, config):
    """
    TBD
    """
    # pylint: disable=invalid-name

    # Specify the table start row where conditional formatting should start
    startrow = 3
    # Create a red background format for the conditional formatting
    format_red = workbook.add_format({"bg_color": "#C0504D", "align": "left", "valign": "vcenter"})
    # Create a orange background format for the conditional formatting
    format_orange = workbook.add_format({"bg_color": "#F79646", "align": "left", "valign": "vcenter"})
    # Create a green background format for the conditional formatting
    format_green = workbook.add_format({"bg_color": "#9BBB59", "align": "left", "valign": "vcenter"})

    # Create a conditional formatting for each column in the list.
    column_list = ["sr_no_owner", "is_covered", "coverage_action_needed", "api_action_needed"]
    # Create a conditional formatting for each column in the list.
    column_list = ["sr_no_owner", "is_covered", "coverage_action_needed", "api_action_needed"]
    column_list = [column for column in column_list if column in df.columns]
    for column in column_list:
        # Get the column letter by the column name
        target_col = xl_col_to_name(df.columns.get_loc(column))
        # -> Excel requires the value for type cell to be double quoted
        worksheet.conditional_format(
            f"{target_col}{startrow}:{target_col}{config['max_row']}",
            {"type": "cell", "criteria": "equal to", "value": '"NO"', "format": format_red},
        )
        worksheet.conditional_format(
            f"{target_col}{startrow}:{target_col}{config['max_row']}",
            {"type": "cell", "criteria": "equal to", "value": '"YES"', "format": format_green},
        )
        worksheet.conditional_format(
            f"{target_col}{startrow}:{target_col}{config['max_row']}",
            {"type": "text", "criteria": "containing", "value": "No action needed", "format": format_green},
        )
        worksheet.conditional_format(
            f"{target_col}{startrow}:{target_col}{config['max_row']}",
            {"type": "text", "criteria": "containing", "value": "Action needed", "format": format_red},
        )

    # Create a conditional formatting for each column with a date. Get the column letter by the column name
    if "grace_period_cols" in config:
        grace_period = config["grace_period_days"] if "grace_period_days" in config else 90
        for column in config["grace_period_cols"]:
            target_col = xl_col_to_name(df.columns.get_loc(column))
            worksheet.conditional_format(
                f"{target_col}{startrow}:{target_col}{config['max_row']}",
                {
                    "type": "date",
                    "criteria": "between",
                    "minimum": datetime.today().date() + timedelta(days=grace_period),
                    "maximum": datetime.strptime("2999-01-01", "%Y-%m-%d"),
                    "format": format_green,
                },
            )
            worksheet.conditional_format(
                f"{target_col}{startrow}:{target_col}{config['max_row']}",
                {
                    "type": "date",
                    "criteria": "between",
                    "minimum": datetime.today().date(),
                    "maximum": datetime.today().date() + timedelta(days=grace_period),
                    "format": format_orange,
                },
            )
            worksheet.conditional_format(
                f"{target_col}{startrow}:{target_col}{config['max_row']}",
                {
                    "type": "date",
                    "criteria": "between",
                    "minimum": datetime.strptime("1999-01-01", "%Y-%m-%d"),
                    "maximum": datetime.today().date() - timedelta(days=1),
                    "format": format_red,
                },
            )

    # Replace all 0 in the current_version and the desired_version to match to the Cisco API recommended
    # version format -> Make 17.03.05 to 17.3.5 == Normalizing IOSXE and non IOSXE version format
    for idx, version in enumerate(df["current_version"].values):
        df["current_version"][idx] = version.replace("0", "")
    for idx, version in enumerate(df["desired_version"].values):
        df["desired_version"][idx] = version.replace("0", "")

    # Create a conditional formatting for the current_version compared with the desired_version
    if "current_version" in df.columns and "desired_version" in df.columns:
        # Get the column letter by the column name
        version_col = xl_col_to_name(df.columns.get_loc("current_version"))
        # Iterate over all cells in current_version and compare the string against the desired_version
        for idx, version in enumerate(df["current_version"].values):
            # If the current_version is in with the desired_version
            if version in df["desired_version"][idx]:
                # enumerate start with 0, but the cell start with 3 -> +3 to match idx with starting cell
                worksheet.write(f"{version_col}{idx + startrow}", version, format_green)
            else:
                # enumerate start with 0, but the cell start with 3 -> +3 to match idx with starting cell
                worksheet.write(f"{version_col}{idx + startrow}", version, format_red)

    # Create a conditional formatting for the desired_version compared with the recommended_version
    if "desired_version" in df.columns and "recommended_version" in df.columns:
        # Get the column letter by the column name
        version_col = xl_col_to_name(df.columns.get_loc("desired_version"))
        # Iterate over all cells in desired_version and compare the string against the recommended_version
        for idx, version in enumerate(df["desired_version"].values):
            # If the desired_version is in with the recommended_version
            if version in df["recommended_version"][idx]:
                # enumerate start with 0, but the cell startrow is different -> +startrow to match start cell
                worksheet.write(f"{version_col}{idx + startrow}", version, format_green)
            else:
                # enumerate start with 0, but the cell startrow is different -> +startrow to match start cell
                worksheet.write(f"{version_col}{idx + startrow}", version, format_orange)

    return worksheet


def generate_cisco_maintenance_report(df: pd.DataFrame, report_cfg: dict) -> None:
    """
    Generate the Cisco Maintenance report Excel file specified by the report_file with the pandas dataframe.
    The function returns None, but saves the Excel file to the local disk.
    """
    # pylint: disable=invalid-name

    # Disable Pandas SettingWithCopyWarning for "chained" assignments
    # -> Error-Message: A value is trying to be set on a copy of a slice from a DataFrame
    # -> https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
    pd.options.mode.chained_assignment = None  # default='warn'

    print_task_name(text="PYTHON create Pandas writer object using XlsxWriter engine")

    #### Create the xlsx writer, workbook and worksheet objects #############################################

    # Get the dimensions of the dataframe.
    (max_row, max_col) = df.shape
    # Max_row + 2 because the first two rows are used for title and header
    report_cfg["max_row"] = max_row + 2
    # Max_com -1 otherwise would be one column to much
    report_cfg["max_col"] = max_col - 1

    # Create a Pandas excel writer using XlsxWriter as the engine.
    writer = pd.ExcelWriter(  # pylint: disable=abstract-class-instantiated
        path=report_cfg["excel_file"],
        engine="xlsxwriter",
        date_format="yyyy-mm-dd",
        datetime_format="yyyy-mm-dd",
    )

    # Get the xlsxwriter workbook object
    workbook = writer.book
    # Write the dataframe data to XlsxWriter. Turn off the default header and index and skip one row to allow
    # us to insert a user defined header.
    sheet_name = report_cfg["sheet_name"] if "sheet_name" in report_cfg else "Cisco_Maintenance_Report"
    df.to_excel(writer, sheet_name=sheet_name, startrow=2, header=False, index=False)
    # Get the xlsxwriter worksheet object
    worksheet = writer.sheets[sheet_name]

    print(task_info(text="PYTHON create XlsxWriter workbook and worksheet", changed=False))
    print("'PYTHON create pandas writer object using XlsxWriter engine' -> PythonResult <Success: True>")

    #### Add content and condidional formatting to the xlsx writer worksheet ################################

    # Add the top title row
    worksheet = _worksheet_add_title_row(workbook=workbook, worksheet=worksheet, config=report_cfg)
    print(task_info(text="PYTHON create XlsxWriter title row", changed=False))
    print("'PYTHON create XlsxWriter title row' -> PythonResult <Success: True>")

    # Add a Excel table structure and add the Pandas dataframe
    worksheet = _worksheet_add_table(df=df, workbook=workbook, worksheet=worksheet, config=report_cfg)
    print(task_info(text="PYTHON create XlsxWriter table and add pandas dataframe", changed=False))
    print("'PYTHON create XlsxWriter table and add pandas dataframe' -> PythonResult <Success: True>")

    # Create conditional formating
    worksheet = _worksheet_add_conditional_formatting(
        df=df, workbook=workbook, worksheet=worksheet, config=report_cfg
    )
    print(task_info(text="PYTHON create XlsxWriter conditional formating", changed=False))
    print("'PYTHON create XlsxWriter conditional formating' -> PythonResult <Success: True>")

    #### Save the Excel report file to disk ##################################################################

    print_task_name(text="PYTHON generate report Excel file")

    # Close the Pandas Excel writer and output the Excel file.
    writer.close()

    print(task_info(text="PYTHON generate report Excel file", changed=False))
    print("'PYTHON generate report Excel file' -> PythonResult <Success: True>")
    print(f"-> Saved information about {df.shape[0]} serials to {report_cfg['excel_file']}")


#### Functions ###############################################################################################


def _init_nornir(args: argparse.Namespace) -> Nornir:
    """
    This function supports the readability and is used within the main() function. The Nornir inventory will
    be initialized, the default username and password will be transformed and loaded from environment
    variables. The same transformation to load the environment variables is done for the mandatory Cisco
    support API credentials and also for all other inventory keys which start with _env. The function returns
    a filtered Nornir object or quits with an error message in case of issues during the function.
    """
    # pylint: disable=invalid-name

    # Initialize Nornir Object with a config file
    nr = InitNornir(config_file="inventory/nr_config.yaml")

    # Transform the Nornir default username and password from environment variables
    nr_transform_default_creds_from_env(nr_obj=nr, verbose=args.verbose)

    # Transform the Nornir inventory and load all env variables staring with "_env" in default.yaml
    nr_transform_inv_from_env(
        iterable=nr.inventory.defaults.data,
        verbose=args.verbose,
        mandatory={
            "cisco_support_api_creds": {
                "env_client_key": "CISCO_SUPPORT_API_KEY",
                "env_client_secret": "CISCO_SUPPORT_API_SECRET",
            },
        },
    )

    # Filter the Nornir inventory based on the provided arguments from init_args
    nr_obj = nr_filter_args(nr_obj=nr, args=args)

    return nr_obj


def _load_report_yaml_config(report_cfg, args):
    """ """
    # If the report_config file string is available
    if report_cfg["yaml_config"]:
        # Load the report variables from the YAML config file as python dictionary
        config = load_yaml_file(
            file=report_cfg["yaml_config"], text="PYTHON load report yaml config file", verbose=args.verbose
        )
        # Update the report_cfg dict with the loaded yaml config
        report_cfg.update(**config)

    # Select the correct string order based on the TSS arguments
    if args.nornir:
        df_order = "nornir_column_order_with_tss" if args.tss else "nornir_column_order"
    else:
        df_order = "static_column_order_with_tss" if args.tss else "static_column_order"

    # Set the df_order to False if the key don't exist
    report_cfg["df_order"] = report_cfg[df_order] if df_order in report_cfg else False
    # Select the correct dataframe order for all dates regarding conditional formatting
    # Set the df_date_columns to False if the key don't exist
    report_cfg["df_date_columns"] = (
        report_cfg["grace_period_cols"] if "grace_period_cols" in report_cfg else False
    )

    return report_cfg


def main() -> None:
    """
    Main function is executed when the file is directly executed.
    """
    # pylint: disable=invalid-name

    #### Initialize Script and Nornir ########################################################################

    print_script_banner(
        title="Cisco Maint-Check",
        text="Cisco maintenance checker with Nornir and the Cisco support APIs",
    )

    print_task_title("Initialize ArgParse")
    # Initialize the script arguments with ArgParse to define the further script execution
    args = init_args(argparse_prog_name=os.path.basename(__file__))

    # Create a dict for configuration specifications
    report_cfg = {}

    if args.nornir:
        print_task_title("Initialize Nornir")
        # Initialize, transform and filter the Nornir inventory are return the filtered Nornir object
        nr_obj = _init_nornir(args=args)
        # Prepare the Cisco support API key and the secret in a tuple
        api_creds = (
            nr_obj.inventory.defaults.data["cisco_support_api_creds"]["env_client_key"],
            nr_obj.inventory.defaults.data["cisco_support_api_creds"]["env_client_secret"],
        )
        # Get the report_config string from the Nornir inventory for later YAML file load
        report_cfg["yaml_config"] = (
            nr_obj.inventory.defaults.data["cisco_maintenance_report"]["yaml_config"]
            if args.report
            else False
        )
        # Get the report_file string from the Nornir inventory for later destination file constructing
        report_cfg["excel_file"] = (
            nr_obj.inventory.defaults.data["cisco_maintenance_report"]["excel_file"] if args.report else False
        )
        # Get the ibm_tss_report file from the Nornir inventory
        report_cfg["ibm_tss_file"] = (
            nr_obj.inventory.defaults.data["cisco_maintenance_report"]["ibm_tss_file"] if args.tss else False
        )
        print_task_title("Prepare Nornir Data")
        # Prepare the serials dict for later processing
        serials = prepare_nornir_data(nr_obj=nr_obj, verbose=args.verbose)

    else:
        print_task_title("Prepare Static Data")
        # Prepare the serials dict for later processing
        serials = prepare_static_serials(args=args)
        # Prepare the Cisco support API key and the secret in a tuple
        api_creds = (args.api_key, args.api_secret)
        # Create the report_config string for later YAML file load
        report_cfg["yaml_config"] = "reports/src/report_config_mmm.yaml"
        # Create the report_file string for later destination file constructing
        report_cfg["excel_file"] = (
            args.excel if args.excel else "reports/cisco_maintenance_report_YYYY-mm-dd.xlsx"
        )
        # Set the ibm_tss_report file
        report_cfg["ibm_tss_file"] = args.tss if args.tss else False

    #### Get Cisco Support-API Data ##########################################################################

    print_task_title("Check Cisco support API OAuth2 client credentials grant flow")

    # Check the API authentication with the client key and secret to get an access token
    # The script will exit with an error message in case the authentication fails
    if not cisco_support_check_authentication(api_creds=api_creds, verbose=args.verbose, silent=False):
        exit_error(task_text="NORNIR cisco maintenance status", text="Bad news! The script failed!")

    print_task_title("Gather Cisco support API data for serial numbers")

    # Cisco Support API Call SNIgetOwnerCoverageStatusBySerialNumbers and update the serials dictionary
    serials = get_sni_owner_coverage_by_serial_number(serial_dict=serials, api_creds=api_creds)
    # Print the results of get_sni_owner_coverage_by_serial_number()
    print_sni_owner_coverage_by_serial_number(serial_dict=serials, verbose=args.verbose)

    # Cisco Support API Call SNIgetCoverageSummaryBySerialNumbers and update the serials dictionary
    serials = get_sni_coverage_summary_by_serial_numbers(serial_dict=serials, api_creds=api_creds)
    # Print the results of get_sni_coverage_summary_by_serial_numbers()
    print_sni_coverage_summary_by_serial_numbers(serial_dict=serials, verbose=args.verbose)

    # Cisco Support API Call EOXgetBySerialNumbers and update the serials dictionary
    serials = get_eox_by_serial_numbers(serial_dict=serials, api_creds=api_creds)
    # Print the results of get_eox_by_serial_numbers()
    print_eox_by_serial_numbers(serial_dict=serials, verbose=args.verbose)

    # Cisco Support API Call getSuggestedReleasesByProductIDs and update the serials dictionary
    serials = get_ss_suggested_release_by_pid(serial_dict=serials, api_creds=api_creds)
    # Print the results of get_ss_suggested_release_by_pid()
    print_get_ss_suggested_release_by_pid(serial_dict=serials, verbose=args.verbose)

    #### Prepate the Excel report data #######################################################################

    # Exit the script if the args.report argument is not set
    if not args.report:
        exit_info(
            task_text="NORNIR cisco maintenance status", text="Good news! The Script successfully finished!"
        )

    print_task_title("Prepare Cisco maintenance report")

    # Load the yaml report config file
    report_cfg = _load_report_yaml_config(report_cfg=report_cfg, args=args)

    # Prepare the report data and create a pandas dataframe
    df = create_pandas_dataframe_for_report(
        serials_dict=serials,
        args=args,
        df_order=report_cfg["df_order"],
        df_date_columns=report_cfg["df_date_columns"],
        tss_report=report_cfg["ibm_tss_file"],
    )

    #### Generate Cisco maintenance report Excel #############################################################

    print_task_title("Generate Cisco maintenance report")

    # Construct the new destination path and filename from the report_file string variable
    report_cfg["excel_file"] = construct_filename_with_current_date(
        filename=report_cfg["excel_file"],
        name="PYTHON construct destination file",
        silent=False,
    )

    # Generate the Cisco Maintenance report Excel file specified by the report_file with the pandas dataframe
    generate_cisco_maintenance_report(df=df, report_cfg=report_cfg)

    exit_info(
        task_text="NORNIR cisco maintenance status", text="Good news! The Script successfully finished!"
    )


if __name__ == "__main__":
    main()
